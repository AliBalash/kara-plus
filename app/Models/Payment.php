<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Payment extends Model
{
    use HasFactory;

    protected $fillable = [
        'contract_id',
        'customer_id',
        'user_id',
        'car_id',
        'amount',
        'payment_method',
        'currency',
        'amount_in_aed',
        'payment_type',
        'description',
        'payment_date',
        'is_refundable',
        'is_paid',
        'rate',
        'receipt',
        'approval_status',
    ];

    protected $casts = [
        'payment_date' => 'date',
        'is_refundable' => 'boolean',
        'is_paid' => 'boolean',
        'approval_status' => 'string',
    ];

    private const SALIK_BREAKDOWN_TYPES = [
        'salik_4_aed',
        'salik_6_aed',
        'salik_other_revenue',
    ];

    public const SALIK_AUTO_OTHER_REVENUE_PREFIX = 'Auto other revenue for Salik payment #';

    public function isSalikBreakdownEntry(): bool
    {
        return in_array($this->payment_type, self::SALIK_BREAKDOWN_TYPES, true);
    }

    public function salikUnitAmount(): float
    {
        return match ($this->payment_type) {
            'salik_4_aed' => 4.0,
            'salik_6_aed' => 6.0,
            'salik_other_revenue' => 1.0,
            default => 0.0,
        };
    }

    public function salikTripCount(): int
    {
        if (! $this->isSalikBreakdownEntry()) {
            return 0;
        }

        $unit = $this->salikUnitAmount();

        if ($unit <= 0.0 || $this->amount_in_aed === null) {
            return 0;
        }

        return (int) round(((float) $this->amount_in_aed) / $unit);
    }

    public function salikBreakdownAmount(): float
    {
        if (! $this->isSalikBreakdownEntry()) {
            return 0.0;
        }

        return (float) $this->amount_in_aed;
    }

    public static function autoGeneratedOtherRevenueDescription(int $paymentId): string
    {
        return self::SALIK_AUTO_OTHER_REVENUE_PREFIX . $paymentId;
    }

    public function isAutoGeneratedSalikOtherRevenue(): bool
    {
        return $this->payment_type === 'salik_other_revenue'
            && is_string($this->description)
            && str_starts_with($this->description, self::SALIK_AUTO_OTHER_REVENUE_PREFIX);
    }

    public function syncAutoGeneratedOtherRevenue(int $tripCount): void
    {
        $description = self::autoGeneratedOtherRevenueDescription($this->id);

        if ($tripCount <= 0) {
            $this->deleteAutoGeneratedOtherRevenue();

            return;
        }

        if (! in_array($this->payment_type, ['salik_4_aed', 'salik_6_aed'], true)) {
            return;
        }

        $paymentDate = $this->payment_date;

        if ($paymentDate instanceof \DateTimeInterface) {
            $paymentDate = $paymentDate->format('Y-m-d');
        }

        $amount = round($tripCount, 2);

        self::updateOrCreate(
            [
                'payment_type' => 'salik_other_revenue',
                'contract_id' => $this->contract_id,
                'customer_id' => $this->customer_id,
                'description' => $description,
            ],
            [
                'user_id' => $this->user_id,
                'amount' => $amount,
                'currency' => 'AED',
                'amount_in_aed' => $amount,
                'payment_method' => $this->payment_method,
                'payment_date' => $paymentDate,
                'is_refundable' => false,
                'is_paid' => $this->is_paid,
                'rate' => null,
                'approval_status' => $this->approval_status,
            ]
        );
    }

    public function deleteAutoGeneratedOtherRevenue(): void
    {
        $description = self::autoGeneratedOtherRevenueDescription($this->id);

        self::where('payment_type', 'salik_other_revenue')
            ->where('contract_id', $this->contract_id)
            ->where('customer_id', $this->customer_id)
            ->where('description', $description)
            ->delete();
    }

    /**
     * دریافت پرداخت‌های انجام‌شده
     */
    public static function getPaidPayments()
    {
        return self::where('is_paid', true)->get();
    }

    /**
     * دریافت پرداخت‌های معوقه
     */
    public static function getUnpaidPayments()
    {
        return self::where('is_paid', false)->get();
    }

    /**
     * دریافت پرداخت‌های قابل استرداد
     */
    public static function getRefundablePayments()
    {
        return self::where('is_refundable', true)->get();
    }

    /**
     * محاسبه کل پرداخت‌های یک قرارداد خاص
     */
    public static function getTotalPaymentsForContract($contractId)
    {
        return self::where('contract_id', $contractId)->sum('amount');
    }

    public function user()
    {
        return $this->belongsTo(User::class, 'user_id');
    }


    /**
     * محاسبه کل مبلغ پرداخت‌شده توسط یک مشتری
     */
    public static function getTotalPaymentsForCustomer($customerId)
    {
        return self::where('customer_id', $customerId)->sum('amount');
    }

    /**
     * ارتباط با قرارداد
     */
    public function contract()
    {
        return $this->belongsTo(Contract::class);
    }

    /**
     * ارتباط با مشتری
     */
    public function customer()
    {
        return $this->belongsTo(Customer::class);
    }

    /**
     * ارتباط با خودرو
     */
    public function car()
    {
        return $this->belongsTo(Car::class);
    }
}
